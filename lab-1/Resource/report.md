# 编译原理Lab1实验报告

| 实验内容 |        词法分析和语法分析         |
| :------: | :-------------------------------: |
|   组长   | 苏海涛 191850169@smail.nju.edu.cn |
|   组员   | 任天骐 191180103@smail.nju.edu.cn |

## 1. 编译运行程序

输入`make`即可。会在Makefile路径下产生可执行文件`parser`。

## 2. 程序功能

**命令行参数检查**：解析器只支持输入一个已经存在的源文件进行解析，文件数目错误或文件不存在会进行报错。

**源文件分析**：对词法和语法均正确的程序，解析器会以先序遍历输出其语法树；对于存在词法或语法错误的程序，解析器会尽可能准确地报告所有错误的类型和位置。

**选做1.1**：实现八进制数和十六进制数的识别。

## 3. 程序实现

### 3.1. 调试宏

`config.h`中可以通过宏启用词法、语法调试模式。启用后，可以在输出中清楚地看到语法分析器的执行过程。用于输出调试信息的函数（例如`error_end`，在归约到一个错误产生式时它会输出提示信息）本身也是宏，在调试宏关闭的情况下，这些输出宏被定义为空，从而不会给程序运行带来额外负担。

### 3.2. 语法树

语法树`node`采用兄弟-子女二叉树实现，节点内信息包括类型（是词法节点还是语法节点）、词法单元名称（字符串类型）、整型数或浮点数取值（联合类型）。`node`结构可能会随后续的要求而改变，以便方便高效地完成更进一步的分析。

`gen_tree`函数可以通过输入多个节点，构造出以这些节点为子女的树。它采用变长参数，从而可以方便地应对不同子女数目的情况。

### 3.3. 错误恢复

书写错误产生式没有遵循太多规律，而是通过不断测试和迭代逐渐稳定下来的，但可以归纳出一些情况：

- 分号一般是语句的结尾，对于那些产物末尾为且仅为分号的非终结符，可以通过产生包含`error SEMI`后缀的产生式来实现错误恢复；
- 对于列表项型的非终结符，例如`VarDec`，如果直接写`VarDec -> error COMMA`会产生问题，因为`COMMA`本身不该属于`VarDec`。但我们仍可以使用此类产生式，只要在归约后让`COMMA`重新出现一次就好。该操作通过设定一个全局变量`repeat`实现，在`YY_USER_ACTION`中如果发现`repeat`有效，就直接返回`repeat`记录的词法单元。这样，我们可以控制`yylex`在下一次调用时一定返回一个我们想要的词法单元，从而实现更精细的错误恢复。
- 对于括号匹配型的非终结符，有两种情况：
  - 括号中的内容有可能匹配失败，可用类似`LP error RP`的产生式；
  - 缺少右括号，下意识想到`LP error`。这么写其实会产生和else匹配一样的二义性问题，那么解决办法也和解决else匹配一样，指定一个优先级低于括号的虚拟符号`NORPRB`即可，然后使用产生式`LP error %prec NORPRB`，使得优先产生括号匹配的产生式。