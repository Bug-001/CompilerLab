# 编译原理Lab4实验报告

| 实验内容 |        词法分析和语法分析         |
| :------: | :-------------------------------: |
|   组号   |                 5                 |
|   组长   | 苏海涛 191850169@smail.nju.edu.cn |
|   组员   | 任天骐 191180103@smail.nju.edu.cn |

## 1. 编译运行程序

输入`make`即可。会在Makefile路径下产生可执行文件`parser`。

`parser`接受一个或两个参数，即：

```
./parser in.cmm [out.s]
```

当`out.s`留空时，`parser`将产生的目标代码打印到`stdout`上。

## 2. 程序功能

- 能够生成在SPIM Simulator上正常运行的程序；
- 向Lab3看齐（即支持高维数组、结构体及将其作为函数参数传递），通过了Lab3基本所有的测试用例（Advanced用例部分未通过，认为是spim出了问题，因为qtspim上可正常运行并输出正确结果）。

## 3. 设计思路

### 3.0. 原则

简单起见，一遍迭代生成正确代码，不过多考虑优化。

### 3.1. 寄存器和内存分配策略

确保每个变量、临时变量等都具有确定的寄存器或内存地址。

- 对于任意用户定义的、未被优化掉的变量，在S0-S8寄存器中分配，寄存器用尽则分配以数据段内存空间；
- 对于任意临时变量，分配以T0-T8寄存器，寄存器用尽后同样分配内存空间。但考虑到临时变量的生命期通常很短，用后即过期，故可以进行复用。

### 3.2. 函数调用策略

- 调用侧：按需将A0-A3寄存器保存到栈中，然后按ARG指令的顺序向寄存器传入参数，寄存器满后将参数压栈，最后将RA寄存器保存到栈中，调用函数。
- 被调用侧：首先保存帧指针FP，然后保存S0-S8寄存器和T0-T8寄存器。按调用侧顺序，最后一个参数保存在A0中，最后第二个在A1，依次类推；若参数超过4个，正数第一个参数保存在`8($fp)`，第二个在`12($fp)`，如此反复，直至倒数四个参数。

### 3.3. 函数返回策略

- 被调用侧：将返回值存入V0，然后将S0-S8寄存器、T0-T8寄存器和栈帧指针恢复。

- 调用侧：和调用时相反即可。注意，必须先恢复寄存器，再将函数返回值存入相应变量的寄存器。如果顺序相反，对于形如

  ```c
  int func(int sum) {
  	// ...
  	sum = func(sum);
      // ...
  }
  ```

  的语句块，`func`的调用的返回值就会在恢复A0寄存器时被覆盖。
